# Chi ti·∫øt lu·ªìng ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p - TiemTra Client

## üéØ T·ªïng quan Authentication System

H·ªá th·ªëng x√°c th·ª±c c·ªßa TiemTra s·ª≠ d·ª•ng **OTP-based verification** k·∫øt h·ª£p v·ªõi **JWT tokens** ƒë·ªÉ ƒë·∫£m b·∫£o b·∫£o m·∫≠t cao. To√†n b·ªô quy tr√¨nh ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ:

- ‚úÖ X√°c minh email th·∫≠t tr∆∞·ªõc khi k√≠ch ho·∫°t t√†i kho·∫£n
- ‚úÖ T·ª± ƒë·ªông qu·∫£n l√Ω JWT tokens (access + refresh)  
- ‚úÖ H·ªó tr·ª£ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u an to√†n qua OTP
- ‚úÖ Ph√¢n quy·ªÅn r√µ r√†ng (Customer vs Admin)

---

## üìù 1. LU·ªíNG ƒêƒÇNG K√ù (SIGN UP)

### üîÑ Workflow t·ªïng quan

```
[ƒêi·ªÅn form] ‚Üí [Validate] ‚Üí [G·ªçi API] ‚Üí [OTP g·ª≠i email] ‚Üí [Verify OTP] ‚Üí [T√†i kho·∫£n k√≠ch ho·∫°t]
```

### üìã Step-by-step chi ti·∫øt

#### **Step 1: Ng∆∞·ªùi d√πng ƒëi·ªÅn th√¥ng tin (`RegisterForm.tsx`)**

**Th√¥ng tin y√™u c·∫ßu:**
```typescript
interface RegisterFormData {
  fullName: string;      // H·ªç v√† t√™n
  email: string;         // Email (ph·∫£i unique)
  phoneNumber: string;   // S·ªë ƒëi·ªán tho·∫°i (format: 0xxxxxxxxx)
  password: string;      // M·∫≠t kh·∫©u (t·ªëi thi·ªÉu 6 k√Ω t·ª±)
}
```

**Client-side validation:**
```typescript
// Email validation
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

// Phone validation (Vietnamese format)
const phoneRegex = /^0\d{9}$/;

// Password validation  
password.length >= 6
```

**UI Components:**
- Material-UI `TextField` v·ªõi real-time validation
- Error messages hi·ªÉn th·ªã ngay l·∫≠p t·ª©c
- Loading state trong qu√° tr√¨nh submit
- Password visibility toggle

#### **Step 2: G·ª≠i request ƒëƒÉng k√Ω**

**Hook s·ª≠ d·ª•ng: `useAuth()`**
```typescript
const { register } = useAuth();

const handleSubmit = async (formData) => {
  const result = await register(formData);
  
  if (result.success) {
    // Chuy·ªÉn sang verify OTP
    navigate("/verify-otp", { state: { email: formData.email } });
  } else {
    // Hi·ªÉn th·ªã l·ªói
    showError(result.message);
  }
};
```

**Redux Action ƒë∆∞·ª£c trigger:**
```typescript
export const registerApi = createAsyncThunk(
  "auth/register",
  async (params: RegisterParams, thunkAPI) => {
    try {
      const response = await authApi.register(params);
      const data = response.data;

      if (!data?.success) {
        return thunkAPI.rejectWithValue(data.message || "ƒêƒÉng k√Ω th·∫•t b·∫°i");
      }

      return data;
    } catch (error: any) {
      return thunkAPI.rejectWithValue(
        error.response?.data?.message || "L·ªói khi ƒëƒÉng k√Ω"
      );
    }
  }
);
```

**API Call:**
```typescript
// Service: src/services/api/Authentication/index.ts
const authApi = {
  register: (params: {
    fullName: string;
    email: string;
    password: string;
    phoneNumber: string;
  }) => requester.post("/api/auth/register", params),
}
```

#### **Step 3: Backend x·ª≠ l√Ω & g·ª≠i OTP**

**Backend response khi th√†nh c√¥ng:**
```json
{
  "success": true,
  "message": "ƒêƒÉng k√Ω th√†nh c√¥ng. Vui l√≤ng ki·ªÉm tra email ƒë·ªÉ x√°c th·ª±c.",
  "data": {
    "userId": "uuid-here",
    "email": "user@example.com",
    "otpSent": true
  }
}
```

**Backend actions:**
1. Validate input data
2. Check email uniqueness  
3. Hash password
4. T·∫°o user record v·ªõi status = "Pending"
5. Generate OTP (6 digits)
6. G·ª≠i OTP qua email
7. L∆∞u OTP v·ªõi expiry time (th∆∞·ªùng 5-10 ph√∫t)

#### **Step 4: User navigate to OTP verification**

**Route transition:**
```typescript
// T·ª´ /register ‚Üí /verify-otp
navigate("/verify-otp", { 
  state: { email: formData.email } 
});
```

**Email ch·ª©a OTP ƒë∆∞·ª£c g·ª≠i ƒë·∫øn user** v·ªõi format:
```
Subject: X√°c th·ª±c t√†i kho·∫£n TiemTra

Xin ch√†o [FullName],

M√£ OTP c·ªßa b·∫°n l√†: 123456

M√£ n√†y c√≥ hi·ªáu l·ª±c trong 10 ph√∫t.

C·∫£m ∆°n,
TiemTra Team
```

---

## ‚úÖ 2. LU·ªíNG X√ÅC TH·ª∞C OTP

### üîÑ Workflow

```
[Nh·∫≠p OTP] ‚Üí [Validate] ‚Üí [G·ªçi API verify] ‚Üí [Account activated] ‚Üí [Redirect to login]
```

### üìã Chi ti·∫øt implementation

#### **Step 1: OTP Input Form (`VerifyOtpForm.tsx`)**

```typescript
const VerifyOtpForm = () => {
  const [otp, setOtp] = useState("");
  const location = useLocation();
  const email = location.state?.email; // L·∫•y email t·ª´ register step

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const result = await verifyOtp({ email, otp });
    
    if (result.success) {
      showSuccess("X√°c th·ª±c th√†nh c√¥ng");
      navigate("/login");
    } else {
      setError(result.message);
    }
  };
}
```

#### **Step 2: API Call & Redux Action**

```typescript
export const verifyOtpApi = createAsyncThunk(
  "auth/verifyOtp", 
  async (params: { email: string; otp: string }, thunkAPI) => {
    try {
      const response = await authApi.verifyOtp(params);
      const data = response.data;

      if (!data?.success || !data.token) {
        return thunkAPI.rejectWithValue(data.message || "M√£ OTP kh√¥ng ƒë√∫ng");
      }

      return data;
    } catch (error: any) {
      return thunkAPI.rejectWithValue(error.response?.data?.message);
    }
  }
);
```

#### **Step 3: Backend verification**

**Backend process:**
1. Find OTP record by email + otp code
2. Check expiry time
3. Validate OTP matches
4. Update user status: "Pending" ‚Üí "Active"
5. Delete used OTP
6. Return success response

**Success response:**
```json
{
  "success": true,
  "message": "X√°c th·ª±c th√†nh c√¥ng",
  "token": "jwt-token-here",
  "data": {
    "userId": "uuid",
    "email": "user@example.com",
    "isVerified": true
  }
}
```

#### **Step 4: Account activation complete**

- User account status = "Active"
- User c√≥ th·ªÉ login b√¨nh th∆∞·ªùng
- Redirect v·ªÅ `/login` page

---

## üîê 3. LU·ªíNG ƒêƒÇNG NH·∫¨P (SIGN IN)

### üîÑ Workflow

```
[Nh·∫≠p email/password] ‚Üí [Validate] ‚Üí [API call] ‚Üí [JWT tokens] ‚Üí [Save to localStorage] ‚Üí [Redirect dashboard]
```

### üìã Chi ti·∫øt implementation

#### **Step 1: Login Form (`LoginForm.tsx`)**

```typescript
const LoginForm = () => {
  const { register, handleSubmit, formState: { errors } } = useForm();
  const { login, loading, error } = useAuth();
  
  const onSubmit = async (data: { email: string; password: string }) => {
    const result = await login(data);
    
    if (result) {
      navigate("/"); // Redirect to home or dashboard
    }
  };
}
```

**Form validation:**
- Email: Required + email format
- Password: Required
- Real-time error display

#### **Step 2: Login API & Redux Action**

```typescript
export const loginApi = createAsyncThunk(
  "auth/login",
  async (params: { email: string; password: string }, thunkAPI) => {
    try {
      const response = await authApi.login(params);
      const data = response.data;

      if (!data?.success || !data?.token) {
        return thunkAPI.rejectWithValue("Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u!");
      }

      // üî• QUAN TR·ªåNG: L∆∞u tokens & user data
      localStorage.setItem("access_token", data.token);
      localStorage.setItem("refresh_token", data.refreshToken || "");
      localStorage.setItem("user", JSON.stringify(data.data));

      // Clear cart khi ƒëƒÉng nh·∫≠p (optional)
      localStorage.removeItem("cart");

      return data;
    } catch (error: any) {
      return thunkAPI.rejectWithValue(
        error.response?.data?.message || "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i"
      );
    }
  }
);
```

#### **Step 3: Backend authentication**

**Backend process:**
1. Find user by email
2. Verify password hash
3. Check account status (Active/Pending/Blocked)
4. Generate JWT access token (short-lived, ~15 mins)
5. Generate refresh token (long-lived, ~7 days)
6. Return tokens + user data

**Success response:**
```json
{
  "success": true,
  "message": "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "refresh-token-here",
  "data": {
    "userId": "uuid",
    "email": "user@example.com", 
    "fullName": "Nguyen Van A",
    "avatar": "avatar-url",
    "roles": ["Customer"] // or ["Admin"]
  }
}
```

#### **Step 4: Client-side token management**

**localStorage structure sau khi login:**
```javascript
{
  "access_token": "jwt-access-token",
  "refresh_token": "jwt-refresh-token", 
  "user": "{\"userId\":\"uuid\",\"email\":\"...\",\"roles\":[\"Customer\"]}"
}
```

**Redux state update:**
```typescript
.addCase(loginApi.fulfilled, (state, action) => {
  state.loading = false;
  state.user = action.payload.data; // User info stored in Redux
})
```

#### **Step 5: Automatic token attachment**

**Axios interceptor t·ª± ƒë·ªông attach token:**
```typescript
// src/services/extended/axiosInstance.ts
requester.interceptors.request.use((config) => {
  const excludedPaths = ["/auth/login", "/auth/register", "/auth/verify-otp"];
  const shouldExclude = excludedPaths.some(path => config.url?.includes(path));

  if (!shouldExclude) {
    const token = getToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});
```

**M·ªçi API call sau login ƒë·ªÅu t·ª± ƒë·ªông c√≥ header:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

## üîÑ 4. AUTOMATIC TOKEN REFRESH SYSTEM

### üéØ V·∫•n ƒë·ªÅ c·∫ßn gi·∫£i quy·∫øt

- Access token c√≥ th·ªùi gian s·ªëng ng·∫Øn (15 ph√∫t)
- User kh√¥ng mu·ªën ph·∫£i login l·∫°i li√™n t·ª•c
- C·∫ßn refresh token t·ª± ƒë·ªông v√† seamless

### üõ†Ô∏è Implementation chi ti·∫øt

#### **Response Interceptor v·ªõi Auto-Refresh**

```typescript
requester.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Ch·ªâ retry khi: 401 error + ch∆∞a retry + kh√¥ng ph·∫£i auth endpoints
    if (error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = getRefreshToken();
        if (!refreshToken) {
          throw new Error("Kh√¥ng t√¨m th·∫•y Refresh Token");
        }

        // üî• Call refresh token API
        const response = await authApi.refreshToken({ refreshToken });
        
        // üî• Update tokens in localStorage
        setTokens(response.data.token, response.data.refreshToken);

        // üî• Retry original request v·ªõi token m·ªõi
        originalRequest.headers.Authorization = `Bearer ${response.data.token}`;
        return axios(originalRequest);
        
      } catch (refreshError) {
        console.error("Refresh token th·∫•t b·∫°i:", refreshError);
        
        // üî• Refresh failed ‚Üí Logout user
        localStorage.removeItem("access_token");
        localStorage.removeItem("refresh_token");
        localStorage.removeItem("user");
        window.location.href = "/login";
      }
    }

    return Promise.reject(error);
  }
);
```

#### **Lu·ªìng ho·∫°t ƒë·ªông c·ªßa Auto-Refresh**

```
[API Request] ‚Üí [401 Error] ‚Üí [Get Refresh Token] ‚Üí [Call Refresh API] 
     ‚Üì
[New Tokens] ‚Üí [Update localStorage] ‚Üí [Retry Original Request] ‚Üí [Success]
     ‚Üì (if refresh fails)
[Clear Storage] ‚Üí [Redirect to Login]
```

**∆Øu ƒëi·ªÉm:**
- ‚úÖ User kh√¥ng c·∫£m nh·∫≠n ƒë∆∞·ª£c token ƒë√£ h·∫øt h·∫°n
- ‚úÖ M·ªçi API call ƒë·ªÅu ƒë∆∞·ª£c retry t·ª± ƒë·ªông
- ‚úÖ Ch·ªâ logout khi refresh token c≈©ng h·∫øt h·∫°n
- ‚úÖ Thread-safe (tr√°nh multiple refresh calls)

---

## üîí 5. PASSWORD RESET WORKFLOW

### üîÑ Workflow t·ªïng quan

```
[Qu√™n m·∫≠t kh·∫©u] ‚Üí [Nh·∫≠p email] ‚Üí [OTP sent] ‚Üí [Verify OTP] ‚Üí [ƒê·∫∑t m·∫≠t kh·∫©u m·ªõi] ‚Üí [Complete]
```

### üìã Step-by-step chi ti·∫øt

#### **Step 1: Forgot Password Page (`ForgotPassword.tsx`)**

```typescript
const ForgotPasswordPage = () => {
  const [otpSent, setOtpSent] = useState(false);
  const [cooldown, setCooldown] = useState(0);
  
  const handleSendOtp = async () => {
    const email = getValues("email");
    const res = await forgotPassword({ email });
    
    setOtpSent(true);
    setCooldown(60); // 60 gi√¢y cooldown
  };
  
  const handleVerifyAndGo = async () => {
    const otp = getValues("otp");
    // Chuy·ªÉn sang reset password page v·ªõi email + otp
    navigate("/reset-password", { state: { email, otp } });
  };
}
```

**Features:**
- Email validation tr∆∞·ªõc khi g·ª≠i OTP
- Cooldown 60 gi√¢y cho n√∫t "G·ª≠i l·∫°i OTP"
- Two-step form: Email ‚Üí OTP input
- Th√¥ng b√°o neutral (kh√¥ng reveal email t·ªìn t·∫°i hay kh√¥ng)

#### **Step 2: OTP Generation & Email**

**Backend process cho forgot password:**
```typescript
// API: /api/auth/forgot-password
{
  email: "user@example.com"
}
```

1. T√¨m user by email
2. Generate OTP (6 digits)
3. Store OTP v·ªõi expiry (10 minutes)
4. G·ª≠i email ch·ª©a OTP
5. Return neutral message

**Email template:**
```
Subject: ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u TiemTra

M√£ OTP ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u: 654321

M√£ n√†y c√≥ hi·ªáu l·ª±c trong 10 ph√∫t.

N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u, vui l√≤ng b·ªè qua email n√†y.

TiemTra Team
```

#### **Step 3: Reset Password Page (`ResetPasswordPage.tsx`)**

```typescript
const ResetPasswordPage = () => {
  const location = useLocation();
  const { email, otp } = location.state || {};
  
  const onSubmit = async (data: ResetPasswordFormValues) => {
    const res = await resetPassword({
      email,
      otp,
      newPassword: data.newPassword
    });

    if (res.success) {
      showSuccess("ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng!");
      navigate("/login");
    } else {
      showError(res.message);
    }
  };
}
```

**Form validation:**
```typescript
{
  newPassword: {
    required: "M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng",
    minLength: { value: 6, message: "√çt nh·∫•t 6 k√Ω t·ª±" }
  },
  confirmPassword: {
    required: "Vui l√≤ng x√°c nh·∫≠n m·∫≠t kh·∫©u",
    validate: (value) => value === watch("newPassword") || "M·∫≠t kh·∫©u kh√¥ng kh·ªõp"
  }
}
```

#### **Step 4: Backend Password Update**

**API Call:**
```typescript
// POST /api/auth/reset-password
{
  email: "user@example.com",
  otp: "654321", 
  newPassword: "new-password-here"
}
```

**Backend process:**
1. Validate OTP v·ªõi email
2. Check OTP ch∆∞a h·∫øt h·∫°n
3. Hash new password  
4. Update user password
5. Invalidate t·∫•t c·∫£ existing tokens
6. Delete used OTP
7. Return success

---

## üõ°Ô∏è 6. PROTECTED ROUTES & AUTHORIZATION

### üéØ Ph√¢n quy·ªÅn trong h·ªá th·ªëng

**User Roles:**
- `Customer`: Kh√°ch h√†ng th∆∞·ªùng (shopping, orders)
- `Admin`: Qu·∫£n tr·ªã vi√™n (dashboard, product management)

### üîí ProtectedRoute Component

```typescript
const ProtectedRoute = ({ children, requiredRole }: ProtectedRouteProps) => {
  const storedUser = localStorage.getItem("user");
  const user = storedUser ? JSON.parse(storedUser) : null;

  // Check if user is logged in
  if (!user) {
    return <UnauthorizedPage />;
  }

  // Check role-based access
  if (requiredRole && !user.roles?.includes(requiredRole)) {
    return (
      <UnauthorizedPage 
        message="B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p trang n√†y" 
        showLoginButton={false}
      />
    );
  }

  return <>{children}</>;
};
```

### üõ£Ô∏è Route Protection Usage

```typescript
// Admin routes v·ªõi role protection
<Route 
  path="/admin" 
  element={
    <ProtectedRoute requiredRole="Admin">
      <AdminDashboard />
    </ProtectedRoute>
  }
>
  <Route path="dashboard" element={<Dashboard />} />
  <Route path="product" element={<Product />} />
  <Route path="category" element={<Category />} />
  <Route path="order" element={<Order />} />
</Route>

// Store routes (public + customer only)
<Route element={<StoreLayout />}>
  <Route path="/" element={<HomePage />} />
  <Route path="/san-pham" element={<ProductList />} />
  <Route path="/gio-hang" element={<CartPage />} />
</Route>
```

---

## üîß 7. STATE MANAGEMENT STRATEGY

### üè™ Redux cho Authentication State

```typescript
interface AuthState {
  user: UserType | null;    // Current logged in user
  loading: boolean;         // API call loading state  
  error: string | null;     // Error messages
}

// Only authentication state lives in Redux
// Server data uses React Query
// UI state uses local useState
```

### üíæ Local Storage Management

```typescript
// Token management utilities
export const getToken = (): string | null => {
  let accessToken = localStorage.getItem("access_token");
  
  if (!accessToken) {
    try {
      const userData = localStorage.getItem("userData");
      accessToken = userData ? JSON.parse(userData)?.id_token : null;
    } catch (error) {
      console.error("L·ªói khi parse userData:", error);
      accessToken = null;
    }
  }

  return accessToken;
};

export const setTokens = (accessToken: string, refreshToken: string) => {
  localStorage.setItem("access_token", accessToken);
  localStorage.setItem("refresh_token", refreshToken);
};
```

### üîÑ useCurrentUser Hook

```typescript
export const useCurrentUser = () => {
  const [user, setUser] = useState<any>(null);

  useEffect(() => {
    const syncUser = () => {
      const storedUser = localStorage.getItem("user");
      setUser(storedUser ? JSON.parse(storedUser) : null);
    };

    syncUser();
    
    // Listen for user changes across components
    window.addEventListener("userChanged", syncUser);
    return () => window.removeEventListener("userChanged", syncUser);
  }, []);

  return user;
};
```

---

## ‚ö° 8. ERROR HANDLING & UX

### üö® Error Scenarios & Handling

#### **Network Errors**
```typescript
try {
  const response = await authApi.login(params);
} catch (error: any) {
  const message = error.response?.data?.message || "K·∫øt n·ªëi m·∫°ng c√≥ v·∫•n ƒë·ªÅ";
  return thunkAPI.rejectWithValue(message);
}
```

#### **Validation Errors**
```typescript
// Client-side validation
const newErrors = {
  email: !emailRegex.test(email) ? "Email kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng" : "",
  phone: !phoneRegex.test(phone) ? "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá" : "",
  password: password.length < 6 ? "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±" : ""
};
```

#### **Server Errors**
```typescript
// Server tr·∫£ v·ªÅ error codes
{
  success: false,
  message: "Email ƒë√£ t·ªìn t·∫°i",
  errorCode: "EMAIL_ALREADY_EXISTS"
}
```

### üé® Loading States & Feedback

**Button Loading States:**
```tsx
<Button
  disabled={loading}
  startIcon={loading ? <CircularProgress size={18} /> : null}
>
  {loading ? "ƒêang ƒëƒÉng nh·∫≠p..." : "ƒêƒÉng nh·∫≠p"}
</Button>
```

**Toast Notifications:**
```typescript
const { showSuccess, showError } = useToast();

// Success
showSuccess("ƒêƒÉng nh·∫≠p th√†nh c√¥ng");

// Error  
showError("Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u");
```

**Form Validation Feedback:**
```tsx
<TextField
  error={!!errors.email}
  helperText={errors.email}
  // Real-time validation display
/>
```

---

## üéØ 9. SECURITY CONSIDERATIONS

### üîê Security Best Practices Implemented

#### **Token Security**
- ‚úÖ Short-lived access tokens (15 minutes)
- ‚úÖ HTTP-only refresh tokens (7 days)
- ‚úÖ Automatic token rotation
- ‚úÖ Secure storage in localStorage (encrypted in production)

#### **Password Security** 
- ‚úÖ Minimum 6 characters requirement
- ‚úÖ Server-side hashing (bcrypt/Argon2)
- ‚úÖ No password transmission in URLs
- ‚úÖ Password visibility toggle

#### **OTP Security**
- ‚úÖ 6-digit random codes
- ‚úÖ Short expiry time (10 minutes)
- ‚úÖ Single-use tokens
- ‚úÖ Rate limiting on OTP requests

#### **API Security**
- ‚úÖ HTTPS only communication
- ‚úÖ Input validation & sanitization
- ‚úÖ Rate limiting on auth endpoints
- ‚úÖ Request timeout handling

---

## üìö 10. TESTING AUTHENTICATION FLOWS

### üß™ Test Cases ƒë·ªÉ verify

#### **Sign Up Flow**
1. ‚úÖ Valid registration creates pending user
2. ‚úÖ Duplicate email shows proper error
3. ‚úÖ Invalid phone format rejected
4. ‚úÖ OTP email sent successfully
5. ‚úÖ Valid OTP activates account
6. ‚úÖ Expired OTP shows error
7. ‚úÖ Invalid OTP shows error

#### **Sign In Flow**  
1. ‚úÖ Valid credentials login successful
2. ‚úÖ Invalid email shows error
3. ‚úÖ Wrong password shows error
4. ‚úÖ Unverified account blocked
5. ‚úÖ Tokens stored correctly
6. ‚úÖ User data populated in Redux

#### **Token Management**
1. ‚úÖ Expired token triggers refresh
2. ‚úÖ Invalid refresh token logs out
3. ‚úÖ Concurrent API calls handle refresh properly
4. ‚úÖ Manual logout clears all storage

#### **Password Reset**
1. ‚úÖ Valid email sends OTP
2. ‚úÖ Invalid email shows neutral message  
3. ‚úÖ Valid OTP allows password reset
4. ‚úÖ Password complexity enforced
5. ‚úÖ Old tokens invalidated after reset

---

## üéì K·∫æT LU·∫¨N CHO SINH VI√äN

### üìñ Ki·∫øn th·ª©c c·∫ßn n·∫Øm v·ªØng:

1. **JWT Authentication Pattern**
   - Access token vs Refresh token
   - Token expiry & rotation
   - Secure storage strategies

2. **Redux Async Actions**
   - createAsyncThunk pattern
   - Error handling with thunkAPI
   - State management best practices

3. **Form Validation**
   - Client-side validation
   - Real-time feedback
   - Error state management

4. **React Router Navigation**
   - Programmatic navigation
   - State passing between routes
   - Protected route patterns

5. **Axios Interceptors**
   - Request/Response modification
   - Automatic retry logic
   - Error handling strategies

### üîß Th·ª±c h√†nh n√™n l√†m:

1. **Trace to√†n b·ªô flow** t·ª´ UI ‚Üí Redux ‚Üí API ‚Üí Backend
2. **Test error scenarios** nh∆∞ network failure, invalid credentials
3. **Understand token lifecycle** v√† automatic refresh mechanism
4. **Practice form validation** patterns v·ªõi React Hook Form
5. **Study security implications** c·ªßa t·ª´ng design decision

### üí° ƒêi·ªÉm m·∫°nh c·ªßa architecture n√†y:

- ‚úÖ **Separation of Concerns**: Auth logic t√°ch bi·ªát r√µ r√†ng
- ‚úÖ **User Experience**: Seamless token refresh, no interruption
- ‚úÖ **Security**: Multi-layer protection v·ªõi OTP + JWT
- ‚úÖ **Scalability**: Easy to extend v·ªõi new auth methods
- ‚úÖ **Maintainability**: Centralized error handling & state management

H·ªá th·ªëng authentication n√†y ƒë·∫£m b·∫£o c·∫£ **security** v√† **user experience**, l√† foundation v·ªØng ch·∫Øc cho m·ªôt e-commerce application production-ready! üöÄ